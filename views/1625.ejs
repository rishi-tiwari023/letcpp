<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 1625: Lexicographically Smallest String After Applying Operations (C++)
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 1625: Lexicographically Smallest String After Applying Operations (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b. You
                can apply either of the following two operations any number of times and in any order on s: Add a to all
                odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = "3456" and a = 5,
                s becomes "3951". Rotate s to the right by b positions. For example, if s = "3456" and b = 1, s becomes
                "6345". Return the lexicographically smallest string you can obtain by applying the above operations any
                number of times on s.
            </p>
            <p><strong>Example:</strong>
                Input: s = "5525", a = 9, b = 2 → Output: "2050". We can apply operations: Start "5525" → Rotate "2555"
                → Add "2454" → Add "2353" → Rotate "5323" → Add "5222" → Add "5121" → Rotate "2151" → Add "2050". Input:
                s = "74", a = 5, b = 1 → Output: "24". Operations: "74" → Rotate "47" → Add "42" → Rotate "24".
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    string findLexSmallestString(string str, int addVal, int rotateBy) {
        string smallest = str;
        exploreStates(str, addVal, rotateBy, {}, smallest);
        return smallest;
    }
    
private:
    // DFS to explore all reachable strings using add and rotate operations
    void exploreStates(string current, int addVal, int rotateBy, unordered_set&lt;string&gt;&amp;&amp; visited, string&amp; smallest) {
        // If we've already seen this string, skip it to prevent infinite recursion
        if (visited.contains(current))
            return;
        visited.insert(current);
        smallest = min(smallest, current);  // Keep track of lexicographically smallest string
        
        // Explore next states after performing add and rotate operations
        exploreStates(addOddPositions(current, addVal), addVal, rotateBy, std::move(visited), smallest);
        exploreStates(rotateString(current, rotateBy), addVal, rotateBy, std::move(visited), smallest);
    }
    
    // Add operation: Add 'addVal' to all digits at odd indices (1, 3, 5, ...)
    string addOddPositions(string&amp; s, int addVal) {
        for (int i = 1; i &lt; s.length(); i += 2)
            s[i] = '0' + (s[i] - '0' + addVal) % 10;
        return s;
    }
    
    // Rotate operation: Move the last 'rotateBy' characters to the front
    string rotateString(const string&amp; s, int rotateBy) {
        int n = s.length();
        return s.substr(n - rotateBy) + s.substr(0, n - rotateBy);
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">← Back to Home</a>
    </main>
</body>

</html>