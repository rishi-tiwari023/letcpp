<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 3721: Longest Balanced Subarray II
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 3721: Longest Balanced Subarray II (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given an integer array nums. A subarray is called balanced if it contains an equal number of
                distinct even and distinct odd integers. Return the length of the longest balanced subarray. This is the
                optimized version for larger constraints compared to Problem 3719.
            </p>
            <p><strong>Example:</strong>
                Input: nums = [1,2,3,4,2,1]<br>
                Output: 6<br>
                Explanation: The entire array contains 2 distinct odd numbers (1,3) and 2 distinct even numbers (2,4),
                making it balanced with length 6.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct SegmentTree {
    int size;
    vector&lt;int&gt; minVal, maxVal, lazy;
    SegmentTree(int n) : size(n), minVal(4*n,0), maxVal(4*n,0), lazy(4*n,0) {}
    void pushDown(int node){
        if(lazy[node]){
            for(int child : {2*node, 2*node+1}){
                minVal[child] += lazy[node];
                maxVal[child] += lazy[node];
                lazy[child] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
    void rangeAdd(int node,int left,int right,int ql,int qr,int value){
        if(qr &lt; left || right &lt; ql) return;
        if(ql &lt;= left &amp;&amp; right &lt;= qr){
            minVal[node] += value;
            maxVal[node] += value;
            lazy[node] += value;
            return;
        }
        pushDown(node);
        int mid = (left + right) / 2;
        rangeAdd(2*node, left, mid, ql, qr, value);
        rangeAdd(2*node+1, mid+1, right, ql, qr, value);
        minVal[node] = min(minVal[2*node], minVal[2*node+1]);
        maxVal[node] = max(maxVal[2*node], maxVal[2*node+1]);
    }
    int findFirstZero(int node,int left,int right,int ql,int qr){
        if(qr &lt; left || right &lt; ql) return -1;
        // If segment cannot contain zero, skip early
        if(minVal[node] &gt; 0 || maxVal[node] &lt; 0) return -1;
        if(left == right) return left;
        pushDown(node);
        int mid = (left + right) / 2;
        int res = findFirstZero(2*node, left, mid, ql, qr);
        if(res != -1) return res;
        return findFirstZero(2*node+1, mid+1, right, ql, qr);
    }
};
class Solution {
public:
    int longestBalanced(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        SegmentTree segTree(n);
        unordered_map&lt;int,int&gt; lastIndex;
        int maxLen = 0;
        for(int right = 0; right &lt; n; right++){
            int value = nums[right];
            int prevIndex = lastIndex.count(value) ? lastIndex[value] : -1;
            // Even contributes +1, odd contributes -1
            int weight = (value % 2 == 0) ? 1 : -1;
            segTree.rangeAdd(1, 0, n-1, prevIndex+1, right, weight);
            int left = segTree.findFirstZero(1, 0, n-1, 0, right);
            if(left != -1)
                maxLen = max(maxLen, right - left + 1);
            lastIndex[value] = right;
        }
        return maxLen;
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>

</html>