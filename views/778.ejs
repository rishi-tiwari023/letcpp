<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 778: Swim in Rising Water (C++)
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 778: Swim in Rising Water (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that
                point (i, j). The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim
                from a square to another 4-directionally adjacent square if and only if the elevation of both squares
                individually are at most t. You can swim infinite distances in zero time. Of course, you must stay
                within the boundaries of the grid during your swim. Return the least time until you can reach the bottom
                right square (n - 1, n - 1) if you start at the top left square (0, 0).
            </p>
            <p><strong>Example:</strong>
                Input: grid = [[0,2],[1,3]] → Output: 3. At time 0, you are in grid location (0,0). You cannot go
                anywhere until time 3, when the water depth allows you to reach (1,1). Input: grid =
                [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] → Output: 16. We need to
                wait until time 16 so that (0,0) and (4,4) are connected.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int n = grid.size();
        int time = grid[0][0];  // minimum time needed to reach so far
        
        using Cell = tuple&lt;int, int, int&gt;; // (height, row, col)
        priority_queue&lt;Cell, vector&lt;Cell&gt;, greater&lt;&gt;&gt; pq;
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));
        
        pq.emplace(grid[0][0], 0, 0);
        visited[0][0] = true;
        
        while (!pq.empty()) {
            auto [h, r, c] = pq.top();
            pq.pop();
            time = max(time, h); // we can only move when water is at least this high
            
            if (r == n - 1 &amp;&amp; c == n - 1)
                return time; // reached destination
            
            for (auto [dr, dc] : directions) {
                int nr = r + dr, nc = c + dc;
                if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= n || visited[nr][nc])
                    continue;
                visited[nr][nc] = true;
                pq.emplace(grid[nr][nc], nr, nc);
            }
        }
        
        return time;
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">← Back to Home</a>
    </main>
</body>

</html>