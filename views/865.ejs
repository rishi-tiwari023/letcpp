<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 865: Smallest Subtree with all the Deepest Nodes (C++)
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 865: Smallest Subtree with all the Deepest Nodes (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                Given the root of a binary tree, return the smallest subtree such that it contains all the deepest nodes
                in
                the original tree. A node is called the deepest if it has the largest depth possible among any node in
                the
                entire tree. The subtree of a node is a tree consisting of that node, plus the set of all descendants of
                that node. The solution uses postorder DFS to calculate the maximum depth in left and right subtrees.
                When
                both subtrees have equal maximum depth, the current node is the lowest common ancestor (LCA) of all
                deepest
                nodes.
            </p>
            <p><strong>Example:</strong>
                Input: root = [3,5,1,6,2,0,8,null,null,7,4] → Output: [2,7,4]. The deepest nodes are 7 and 4, and their
                LCA
                is node 2.
                Input: root = [1] → Output: [1]. Single node is both deepest and the answer.
                Input: root = [0,1,3,null,2] → Output: [2]. The deepest node is 2, so return it.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    TreeNode* result = nullptr;
    int deepest = 0;
    int dfs(TreeNode* node, int level) {
        if (!node) return level;
        int left = dfs(node-&gt;left, level + 1);
        int right = dfs(node-&gt;right, level + 1);
        // Update only when this node covers all deepest nodes
        if (left == right &amp;&amp; left &gt;= deepest) {
            deepest = left;
            result = node;
        }
        return max(left, right);
    }
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        dfs(root, 0);
        return result;
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">← Back to Home</a>
    </main>
</body>

</html>