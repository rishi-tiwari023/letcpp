<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 3354: Make Array Elements Equal to Zero (C++)
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 3354: Make Array Elements Equal to Zero (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given an integer array nums. Start by selecting a starting position curr such that nums[curr] ==
                0,
                and choose a movement direction of either left or right. After that, you repeat the following process:
                If curr is out of the range [0, n - 1], this process ends. If nums[curr] == 0, move in the current
                direction
                by incrementing curr if you are moving right, or decrementing curr if you are moving left. Else if
                nums[curr] > 0,
                decrement nums[curr] by 1, and reverse your movement direction (left becomes right and vice versa).
                Continue
                the process until you can no longer move. Return the number of possible starting positions and
                directions that
                make every element in nums equal to 0.
            </p>
            <p><strong>Example:</strong>
                Input: nums = [1,0,2,0,3] → Output: 2. The valid selections are: Choose curr = 1 moving left, Choose
                curr = 3 moving right.
                Input: nums = [2,3,4,0,4,1,0] → Output: 0. There are no possible selections.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    int countValidSelections(vector&lt;int&gt;&amp; a) {
        int n = a.size(), res = 0;
        vector&lt;int&gt; pre(n), suf(n);  // prefix and suffix sums
        // Build prefix sums (sum before each index)
        for (int i = 1; i &lt; n; ++i)
            pre[i] = pre[i - 1] + a[i - 1];
        // Build suffix sums (sum after each index)
        for (int i = n - 2; i &gt;= 0; --i)
            suf[i] = suf[i + 1] + a[i + 1];
        // Check each index as potential starting point
        for (int i = 0; i &lt; n; ++i) {
            if (a[i] &gt; 0) continue;  // must start from a zero element
            // Case 1: Equal sums on both sides → can move both ways
            if (pre[i] == suf[i])
                res += 2;
            // Case 2: One side has exactly one extra → only one valid direction
            if (abs(pre[i] - suf[i]) == 1)
                res += 1;
        }
        return res;
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">← Back to Home</a>
    </main>
</body>

</html>