<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 85: Maximal Rectangle (C++)
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 85: Maximal Rectangle (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only
                1's
                and return its area. The solution first preprocesses the matrix to compute the width of consecutive 1's
                ending at each position. Then, for each cell as a potential bottom-right corner of a rectangle, it
                extends
                upward row by row, maintaining the minimum width seen so far. The area is calculated as minimum_width *
                height at each step. This approach treats each column as a histogram problem.
            </p>
            <p><strong>Example:</strong>
                Input: matrix =
                [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
                → Output: 6. The maximal rectangle is formed by columns 1-3 and rows 1-2, giving area 3*2 = 6.
                Input: matrix = [["0"]] → Output: 0. No 1's present.
                Input: matrix = [["1"]] → Output: 1. Single cell with 1.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; m) {
        int r = m.size(), c = m[0].size(), ans = 0;
        vector&lt;vector&lt;int&gt;&gt; w(r, vector&lt;int&gt;(c, 0));
        // store continuous 1s to the left
        for (int i = 0; i &lt; r; i++)
            for (int j = 0; j &lt; c; j++)
                w[i][j] = (m[i][j] == '1') ? (j ? w[i][j-1] : 0) + 1 : 0;
        // try each cell as bottom
        for (int i = 0; i &lt; r; i++) {
            for (int j = 0; j &lt; c; j++) {
                int mn = w[i][j];
                for (int k = i; k &gt;= 0 &amp;&amp; mn &gt; 0; k--) {
                    mn = min(mn, w[k][j]); // smallest width so far
                    ans = max(ans, mn * (i - k + 1));
                }
            }
        }
        return ans;
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">← Back to Home</a>
    </main>
</body>

</html>