<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 761: Special Binary String
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 761: Special Binary String (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                Special binary strings are binary strings with the following two properties: (1) The number of 0's is
                equal to the number of 1's. (2) Every prefix of the binary string has at least as many 1's as 0's. You
                can swap any two consecutive special substrings. Given a special binary string s, return the
                lexicographically largest special binary string you can make using any number of swaps.
            </p>
            <p><strong>Example:</strong>
                Input: s = "11011000"<br>
                Output: "11100100"<br>
                Explanation: The strings "10" [at indices 1-2] and "1100" [at indices 3-6] are swappable, resulting in
                "11100100". No further swaps can increase the lexicographic order.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
public:
    string makeLargestSpecial(string str) {
        int start = 0;
        int ones = 0, zeros = 0;
        int len = str.size();
        vector&lt;string&gt; parts;
        for (int end = 0; end &lt; len; end++) {
            if (str[end] == '1') 
                ones++;
            else 
                zeros++;
            // When 1s == 0s, we found a valid special substring
            if (ones == zeros) {
                string inner = makeLargestSpecial(str.substr(start + 1, end - start - 1));
                parts.push_back("1" + inner + "0");
                start = end + 1;  // Move to next segment
            }
        }
        // Arrange in descending order to get lexicographically largest result
        sort(parts.rbegin(), parts.rend());
        string finalStr;
        for (auto &amp;segment : parts)
            finalStr += segment;
        return finalStr;
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">‚Üê Back to Home</a>
    </main>
</body>

</html>