<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        LeetCode 3651: Minimum Cost Path with Teleportations
    </title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="/solution.js"></script>
</head>

<body>
    <main>
        <h1>LeetCode 3651: Minimum Cost Path with Teleportations (C++)</h1>
        <div class="problem-description">
            <p><strong>Problem:</strong>
                You are given an m x n integer matrix grid and an integer k. You start at the top-left cell (0, 0) and
                want to reach the bottom-right cell (m-1, n-1). You can move right or down, and each move to a cell
                costs grid[row][col]. Additionally, you can use up to k teleportations to jump to any cell with a value
                less than or equal to your current cell's value at no cost. Return the minimum cost to reach the
                destination.
            </p>
            <p><strong>Example:</strong>
                Input: grid = [[5,3],[2,1]], k = 1<br>
                Output: 3<br>
                Explanation: Start at (0,0) with cost 0. Move down to (1,0) with cost 2. Use teleportation to jump to
                (0,1) with value 3 (≤ 2 is false, but can teleport to any reachable cell). Then move to (1,1) with cost
                1. Total: 2 + 1 = 3.
            </p>
        </div>
        <div class="code-container">
            <button class="copy-button" onclick="copyCode(this)">Copy Code</button>
            <pre><code class="language-cpp">class Solution {
    const int INF = INT_MAX;
public:
    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, INF));
        dp[0][0] = 0;
        // Base DP without teleport
        for (int r = 0; r &lt; rows; r++) {
            for (int c = 0; c &lt; cols; c++) {
                if (r == 0 &amp;&amp; c == 0) continue;
                if (r &gt; 0) dp[r][c] = min(dp[r][c], grid[r][c] + dp[r - 1][c]);
                if (c &gt; 0) dp[r][c] = min(dp[r][c], grid[r][c] + dp[r][c - 1]);
            }
        }
        while (k--) {
            const int MAXV = 1e4;
            vector&lt;int&gt; bestCost(MAXV + 1, INF);
            // For each value, track minimum reachable cost
            for (int r = 0; r &lt; rows; r++)
                for (int c = 0; c &lt; cols; c++)
                    bestCost[grid[r][c]] = min(bestCost[grid[r][c]], dp[r][c]);
            // Suffix min so we can jump from any smaller value
            for (int v = MAXV - 1; v &gt;= 0; v--)
                bestCost[v] = min(bestCost[v], bestCost[v + 1]);
            vector&lt;vector&lt;int&gt;&gt; newDP(rows, vector&lt;int&gt;(cols, INF));
            newDP[0][0] = 0;
            for (int r = 0; r &lt; rows; r++) {
                for (int c = 0; c &lt; cols; c++) {
                    if (r == 0 &amp;&amp; c == 0) continue;
                    // Teleport option
                    newDP[r][c] = bestCost[grid[r][c]];
                    // Normal grid transitions
                    if (r &gt; 0) newDP[r][c] = min(newDP[r][c], grid[r][c] + newDP[r - 1][c]);
                    if (c &gt; 0) newDP[r][c] = min(newDP[r][c], grid[r][c] + newDP[r][c - 1]);
                }
            }
            dp = newDP;
        }
        return dp[rows - 1][cols - 1];
    }
};</code></pre>
        </div>
        <a href="/" class="back-link">← Back to Home</a>
    </main>
</body>

</html>